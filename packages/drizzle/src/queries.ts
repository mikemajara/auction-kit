/**
 * Database query functions
 * 
 * Provides high-level functions for auction operations:
 * - Creating auctions and bidders
 * - Placing bids
 * - Resolving auctions
 * - Querying auction state
 */

import { eq, and, desc } from 'drizzle-orm'
import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { auctions, bidders, bids, settlements, items } from './schema'
import type {
  NewAuction,
  NewBidder,
  NewBid,
  Auction,
  Bidder,
  Bid,
  Item,
  NewItem,
} from './schema'
import { settleBids as settleCore, validateBid } from '@auction-kit/core'
import type { AuctionConfig, ResolutionResult } from '@auction-kit/core'

/**
 * Database type
 */
export type Database = PostgresJsDatabase<Record<string, never>>

/**
 * Create a new auction
 */
export async function createAuction(
  db: Database,
  config: AuctionConfig
): Promise<Auction> {
  const newAuction: NewAuction = {
    config,
    status: 'open',
  }

  const [auction] = await db.insert(auctions).values(newAuction).returning()
  
  if (!auction) {
    throw new Error('Failed to create auction')
  }

  return auction
}

/**
 * Get auction by ID
 */
export async function getAuction(
  db: Database,
  auctionId: string
): Promise<Auction | null> {
  const [auction] = await db
    .select()
    .from(auctions)
    .where(eq(auctions.id, auctionId))
    .limit(1)

  return auction ?? null
}

/**
 * Update auction status
 */
export async function updateAuctionStatus(
  db: Database,
  auctionId: string,
  status: 'open' | 'closed' | 'resolved'
): Promise<Auction> {
  const [auction] = await db
    .update(auctions)
    .set({ 
      status,
      ...(status === 'resolved' ? { resolvedAt: new Date() } : {})
    })
    .where(eq(auctions.id, auctionId))
    .returning()

  if (!auction) {
    throw new Error(`Auction ${auctionId} not found`)
  }

  return auction
}

/**
 * Create a new bidder
 */
export async function createBidder(
  db: Database,
  auctionId: string,
  name: string
): Promise<Bidder> {
  const newBidder: NewBidder = {
    auctionId,
    name,
  }

  const [bidder] = await db.insert(bidders).values(newBidder).returning()

  if (!bidder) {
    throw new Error('Failed to create bidder')
  }

  return bidder
}

/**
 * Get bidder by ID
 */
export async function getBidder(
  db: Database,
  bidderId: string
): Promise<Bidder | null> {
  const [bidder] = await db
    .select()
    .from(bidders)
    .where(eq(bidders.id, bidderId))
    .limit(1)

  return bidder ?? null
}

/**
 * Get all bidders for an auction
 */
export async function getBiddersByAuction(
  db: Database,
  auctionId: string
): Promise<Bidder[]> {
  return db
    .select()
    .from(bidders)
    .where(eq(bidders.auctionId, auctionId))
}

/**
 * Create an item for an auction
 */
export async function createItem(
  db: Database,
  input: {
    auctionId: string
    name: string
    description?: string
    quantity?: number
  }
): Promise<Item> {
  const newItem: NewItem = {
    auctionId: input.auctionId,
    name: input.name,
    description: input.description ?? null,
    quantity: input.quantity ?? 1,
  }

  const [item] = await db.insert(items).values(newItem).returning()

  if (!item) {
    throw new Error('Failed to create item')
  }

  return item
}

/**
 * Get all items for an auction
 */
export async function getItemsByAuction(
  db: Database,
  auctionId: string
): Promise<Item[]> {
  return db
    .select()
    .from(items)
    .where(eq(items.auctionId, auctionId))
}

/**
 * Get an item by ID
 */
export async function getItem(
  db: Database,
  itemId: string
): Promise<Item | null> {
  const [item] = await db
    .select()
    .from(items)
    .where(eq(items.id, itemId))
    .limit(1)

  return item ?? null
}

/**
 * Place a new bid
 * 
 * Validates the bid before inserting
 */
export async function placeBid(
  db: Database,
  input: {
    auctionId: string
    bidderId: string
    itemId: string
    amount: number
  }
): Promise<Bid> {
  // Get auction for validation
  const auction = await getAuction(db, input.auctionId)
  if (!auction) {
    throw new Error(`Auction ${input.auctionId} not found`)
  }

  // Get bidder for validation
  const bidder = await getBidder(db, input.bidderId)
  if (!bidder) {
    throw new Error(`Bidder ${input.bidderId} not found`)
  }
  if (bidder.auctionId !== input.auctionId) {
    throw new Error(`Bidder ${input.bidderId} is not registered in auction ${input.auctionId}`)
  }

  // Validate item exists for this auction
  const item = await getItem(db, input.itemId)
  if (!item) {
    throw new Error(`Item ${input.itemId} not found`)
  }
  if (item.auctionId !== input.auctionId) {
    throw new Error(`Item ${input.itemId} does not belong to auction ${input.auctionId}`)
  }

  // Create bid object for validation
  const bidToValidate: Bid = {
    id: 'temp', // Will be generated by DB
    ...input,
    placedAt: new Date(),
    status: 'active',
  }

  // Convert DB auction to core auction type
  const coreAuction = {
    ...auction,
    createdAt: new Date(auction.createdAt),
    resolvedAt: auction.resolvedAt ? new Date(auction.resolvedAt) : undefined,
  }

  // Validate bid
  const validation = validateBid(bidToValidate, coreAuction)
  if (!validation.valid) {
    throw new Error(`Invalid bid: ${validation.errors.join(', ')}`)
  }

  // Insert bid
  const newBid: NewBid = {
    ...input,
    status: 'active',
  }

  const [bid] = await db.insert(bids).values(newBid).returning()

  if (!bid) {
    throw new Error('Failed to place bid')
  }

  return bid
}

/**
 * Get all bids for an auction
 */
export async function getBidsByAuction(
  db: Database,
  auctionId: string
): Promise<Bid[]> {
  return db
    .select()
    .from(bids)
    .where(eq(bids.auctionId, auctionId))
}

/**
 * Get all active bids for an auction
 */
export async function getActiveBidsByAuction(
  db: Database,
  auctionId: string
): Promise<Bid[]> {
  return db
    .select()
    .from(bids)
    .where(and(
      eq(bids.auctionId, auctionId),
      eq(bids.status, 'active')
    ))
}

/**
 * Resolve an auction
 * 
 * Performs settlement in a transaction:
 * 1. Fetches all active bids
 * 2. Runs core settlement logic
 * 3. Updates bid statuses
 * 4. Creates settlement records
 * 5. Updates auction status to resolved
 */
export async function resolveAuction(
  db: Database,
  auctionId: string,
  randomSeed?: number
): Promise<ResolutionResult> {
  return await db.transaction(async (tx) => {
    // Get auction
    const auction = await getAuction(tx, auctionId)
    if (!auction) {
      throw new Error(`Auction ${auctionId} not found`)
    }

    if (auction.status === 'resolved') {
      throw new Error('Auction is already resolved')
    }

    // Get all active bids
    const activeBids = await getActiveBidsByAuction(tx, auctionId)

    if (activeBids.length === 0) {
      throw new Error('No active bids to resolve')
    }

    // Convert DB bids to core bid format
    const coreBids = activeBids.map(bid => ({
      ...bid,
      placedAt: new Date(bid.placedAt),
    }))

    // Run core settlement logic
    const result = settleCore(coreBids, auction.config, randomSeed)

    if (result.errors.length > 0) {
      throw new Error(`Settlement failed: ${result.errors.join(', ')}`)
    }

    // Create a map of winning bid IDs
    const winningBidIds = new Set<string>()
    const bidIdsByBidderAndItem = new Map<string, string>()

    for (const bid of activeBids) {
      const key = `${bid.bidderId}:${bid.itemId}`
      bidIdsByBidderAndItem.set(key, bid.id)
    }

    // Update bid statuses and create settlements
    for (const settlement of result.settlements) {
      const key = `${settlement.bidderId}:${settlement.itemId}`
      const winningBidId = bidIdsByBidderAndItem.get(key)
      
      if (winningBidId) {
        winningBidIds.add(winningBidId)

        // Update winning bid status
        await tx
          .update(bids)
          .set({ status: 'won' })
          .where(eq(bids.id, winningBidId))

        // Create settlement record
        await tx.insert(settlements).values({
          auctionId,
          bidderId: settlement.bidderId,
          itemId: settlement.itemId,
          wonAmount: settlement.wonAmount,
          bidAmount: settlement.bidAmount,
        })
      }
    }

    // Update losing bids
    for (const bid of activeBids) {
      if (!winningBidIds.has(bid.id)) {
        await tx
          .update(bids)
          .set({ status: 'lost' })
          .where(eq(bids.id, bid.id))
      }
    }

    // Mark auction as resolved
    await updateAuctionStatus(tx, auctionId, 'resolved')

    return result
  })
}

/**
 * Get auction state
 * 
 * Returns complete auction information including bids and settlements
 */
export async function getAuctionState(
  db: Database,
  auctionId: string
) {
  const auction = await getAuction(db, auctionId)
  if (!auction) {
    throw new Error(`Auction ${auctionId} not found`)
  }

  const allBidders = await getBiddersByAuction(db, auctionId)
  const allBids = await getBidsByAuction(db, auctionId)
  const allItems = await getItemsByAuction(db, auctionId)
  
  const allSettlements = await db
    .select()
    .from(settlements)
    .where(eq(settlements.auctionId, auctionId))

  return {
    auction,
    bidders: allBidders,
    bids: allBids,
    items: allItems,
    settlements: allSettlements,
  }
}

/**
 * Cancel a bid
 */
export async function cancelBid(
  db: Database,
  bidId: string
): Promise<Bid> {
  const [bid] = await db
    .update(bids)
    .set({ status: 'cancelled' })
    .where(eq(bids.id, bidId))
    .returning()

  if (!bid) {
    throw new Error(`Bid ${bidId} not found`)
  }

  return bid
}

/**
 * Get all auctions with optional filtering
 */
export async function getAllAuctions(
  db: Database,
  filters?: {
    status?: 'open' | 'closed' | 'resolved'
    limit?: number
    offset?: number
  }
): Promise<Auction[]> {
  let query = db
    .select()
    .from(auctions)

  if (filters?.status) {
    query = query.where(eq(auctions.status, filters.status)) as any
  }

  query = query.orderBy(desc(auctions.createdAt)) as any

  if (filters?.limit) {
    query = query.limit(filters.limit) as any
  }

  if (filters?.offset) {
    query = query.offset(filters.offset) as any
  }

  return query
}

/**
 * Update bidder
 */
export async function updateBidder(
  db: Database,
  bidderId: string,
  updates: { name?: string }
): Promise<Bidder> {
  const [bidder] = await db
    .update(bidders)
    .set(updates)
    .where(eq(bidders.id, bidderId))
    .returning()

  if (!bidder) {
    throw new Error(`Bidder ${bidderId} not found`)
  }

  return bidder
}

/**
 * Update item
 */
export async function updateItem(
  db: Database,
  itemId: string,
  updates: {
    name?: string
    description?: string | null
    quantity?: number
  }
): Promise<Item> {
  const [item] = await db
    .update(items)
    .set(updates)
    .where(eq(items.id, itemId))
    .returning()

  if (!item) {
    throw new Error(`Item ${itemId} not found`)
  }

  return item
}

/**
 * Get bid by ID
 */
export async function getBid(
  db: Database,
  bidId: string
): Promise<Bid | null> {
  const [bid] = await db
    .select()
    .from(bids)
    .where(eq(bids.id, bidId))
    .limit(1)

  return bid ?? null
}

/**
 * Update bid
 */
export async function updateBid(
  db: Database,
  bidId: string,
  updates: {
    amount?: number
    status?: 'active' | 'won' | 'lost' | 'cancelled'
  }
): Promise<Bid> {
  const [bid] = await db
    .update(bids)
    .set(updates)
    .where(eq(bids.id, bidId))
    .returning()

  if (!bid) {
    throw new Error(`Bid ${bidId} not found`)
  }

  return bid
}




